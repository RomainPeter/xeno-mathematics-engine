# üöÄ Orchestrator v1 - Industrial Pipeline

## üìã Vue d'ensemble

L'Orchestrator v1 est la version industrielle du pipeline de d√©couverte, rempla√ßant tous les composants mock√©s par de vrais moteurs, adaptateurs et planificateurs. Il ex√©cute des algorithmes FCA r√©els, de la synth√®se CEGIS, et de la v√©rification concurrente avec gestion des budgets et √©mission d'incidents.

## üèóÔ∏è Architecture

### Composants R√©els

#### **Moteurs**
- **`RealAEEngine`** : Impl√©mentation FCA avec Next-Closure et statistiques
- **`RealCegisEngine`** : Boucle CEGIS avec synth√®se et raffinement r√©els
- **`AsyncScheduler`** : Planificateur asynchrone avec `asyncio.gather` et timeouts
- **`BudgetManager`** : Gestion des budgets avec backoff exponentiel

#### **Adaptateurs**
- **`LLMAdapter`** : Appels API LLM concurrents avec retry et rate limiting
- **`Verifier`** : V√©rification multi-outils (analyse statique, tests, propri√©t√©s)
- **`OracleAdapter`** : Interface avec oracle de domaine
- **`BanditStrategy`** : Strat√©gie de s√©lection multi-armed bandit
- **`DiversityStrategy`** : Strat√©gie de diversit√© pour exploration

#### **Gestion d'Incidents**
- **`FailReasonFactory`** : Cr√©ation d'incidents structur√©s
- **`IncidentManager`** : Gestion des incidents avec s√©v√©rit√©
- **`IncidentEmitter`** : √âmission d'incidents vers le bus d'√©v√©nements

### Pipeline d'Ex√©cution

```mermaid
graph TD
    A[Orchestrator v1] --> B[Initialisation]
    B --> C[AE Phase]
    C --> D[CEGIS Phase]
    D --> E[Audit Pack]
    E --> F[Cleanup]
    
    C --> C1[Next-Closure]
    C1 --> C2[Oracle Verification]
    C2 --> C3[PCAP Emission]
    
    D --> D1[Candidate Proposal]
    D1 --> D2[Verification]
    D2 --> D3[Refinement]
    D3 --> D4[Convergence Check]
    
    E --> E1[PCAPs]
    E1 --> E2[Incidents]
    E2 --> E3[Metrics]
    E3 --> E4[Manifest]
```

## üéØ Fonctionnalit√©s

### **Ex√©cution Concurrente**
- **LLM + Verifier** : Appels parall√®les avec timeouts
- **AE + CEGIS** : Phases s√©quentielles avec concurrence interne
- **Budget Management** : Surveillance en temps r√©el avec backoff

### **Gestion des Budgets**
- **Time Budgets** : Timeouts par op√©ration et phase
- **Token Budgets** : Limitation des tokens LLM
- **API Call Budgets** : Limitation des appels API
- **Memory Budgets** : Surveillance de la m√©moire

### **S√©curit√© d'Annulation**
- **Task Cancellation** : Annulation s√ªre des t√¢ches restantes
- **Resource Cleanup** : Nettoyage des ressources
- **State Persistence** : Sauvegarde de l'√©tat avant annulation

### **√âmission d'Incidents**
- **FailReason Types** : `time_budget_exceeded`, `max_iters_reached`, etc.
- **Severity Levels** : `low`, `medium`, `high`, `critical`
- **Structured Context** : Contexte d√©taill√© pour chaque incident

## üöÄ Utilisation

### **Installation**

```bash
# Installer les d√©pendances
make -f Makefile.orchestrator_v1 install

# Configuration de l'environnement
export OPENAI_API_KEY="your_api_key"
export ORCHESTRATOR_V1_CONFIG="config.yaml"
```

### **D√©monstration Compl√®te**

```bash
# D√©monstration end-to-end
make -f Makefile.orchestrator_v1 demo

# D√©monstration rapide
make -f Makefile.orchestrator_v1 demo-quick

# Analyse des r√©sultats
make -f Makefile.orchestrator_v1 demo-audit
```

### **Tests**

```bash
# Tests complets
make -f Makefile.orchestrator_v1 test

# Tests sp√©cifiques
make -f Makefile.orchestrator_v1 test-orchestrator-v1
make -f Makefile.orchestrator_v1 test-real-components

# Tests de performance
make -f Makefile.orchestrator_v1 test-performance
```

### **Validation**

```bash
# Validation compl√®te
make -f Makefile.orchestrator_v1 validate

# Linting et formatage
make -f Makefile.orchestrator_v1 lint
make -f Makefile.orchestrator_v1 format
```

## üìä Configuration

### **OrchestratorV1Config**

```python
config = OrchestratorV1Config(
    # Timeouts
    ae_timeout=30.0,
    cegis_propose_timeout=10.0,
    cegis_verify_timeout=15.0,
    cegis_refine_timeout=10.0,
    
    # CEGIS parameters
    cegis_max_iterations=10,
    cegis_max_stable_no_improve=3,
    
    # Real component settings
    enable_budget_management=True,
    enable_async_scheduler=True,
    enable_failreason_emission=True,
    
    # LLM settings
    llm_api_url="https://api.openai.com/v1/chat/completions",
    llm_api_key="your_key",
    llm_model="gpt-4",
    llm_max_tokens=2048,
    llm_temperature=0.1,
    
    # Verifier settings
    verifier_timeout=20.0,
    verifier_tools=["static_analysis", "property_check", "test_execution"],
    
    # Scheduler settings
    max_concurrent_tasks=10,
    scheduler_timeout=30.0,
    
    # Budget settings
    budget_warning_threshold=0.8,
    budget_critical_threshold=0.95,
    budget_overrun_threshold=1.0
)
```

### **Budgets**

```python
budgets = {
    "ae_timeout": 30.0,
    "cegis_timeout": 60.0,
    "llm_max_tokens": 10000,
    "llm_temperature": 0.1,
    "verify_timeout": 20.0,
    "total_budget": 300.0,
    "time": 180.0,
    "tokens": 50000,
    "api_calls": 100
}
```

### **Thresholds**

```python
thresholds = {
    "min_confidence": 0.8,
    "max_iterations": 10,
    "success_rate": 0.9,
    "min_concepts": 3,
    "max_incidents": 5,
    "convergence_threshold": 0.95
}
```

## üîß API

### **OrchestratorV1**

```python
from orchestrator.orchestrator_v1 import OrchestratorV1, OrchestratorV1Config

# Cr√©er l'orchestrateur
orchestrator = OrchestratorV1(
    config=config,
    ae_engine=ae_engine,
    cegis_engine=cegis_engine,
    llm_adapter=llm_adapter,
    verifier=verifier,
    scheduler=scheduler,
    budget_manager=budget_manager,
    event_bus=event_bus
)

# Ex√©cuter le pipeline
state = await orchestrator.run(domain_spec, budgets, thresholds)
```

### **RealAEEngine**

```python
from orchestrator.engines.real_ae_engine import RealAEEngine

# Cr√©er le moteur AE
ae_engine = RealAEEngine(
    oracle_adapter=oracle_adapter,
    bandit_strategy=bandit_strategy,
    diversity_strategy=diversity_strategy
)

# Initialiser
await ae_engine.initialize(domain_spec)

# Ex√©cuter une √©tape
result = await ae_engine.next_closure_step(ae_context)
```

### **RealCegisEngine**

```python
from orchestrator.engines.real_cegis_engine import RealCegisEngine

# Cr√©er le moteur CEGIS
cegis_engine = RealCegisEngine(
    llm_adapter=llm_adapter,
    verifier=verifier,
    synthesis_strategy=synthesis_strategy,
    refinement_strategy=refinement_strategy
)

# Initialiser
await cegis_engine.initialize(domain_spec)

# Proposer un candidat
candidate = await cegis_engine.propose(cegis_context)

# V√©rifier le candidat
verdict = await cegis_engine.verify(candidate, cegis_context)

# Raffiner le candidat
refined = await cegis_engine.refine(candidate, counterexample, cegis_context)
```

### **LLMAdapter**

```python
from orchestrator.adapters.llm_adapter import LLMAdapter, LLMConfig

# Configuration
llm_config = LLMConfig(
    api_url="https://api.openai.com/v1/chat/completions",
    api_key="your_key",
    model="gpt-4",
    max_tokens=2048,
    temperature=0.1,
    timeout=30.0,
    max_retries=3,
    concurrent_requests=5
)

# Cr√©er l'adaptateur
llm_adapter = LLMAdapter(llm_config)

# Initialiser
await llm_adapter.initialize(domain_spec)

# G√©n√©rer du texte
response = await llm_adapter.generate(prompt, max_tokens=1024)

# G√©n√©rer une impl√©mentation
implementation = await llm_adapter.generate_implementation(
    specification=spec,
    context=context,
    constraints=constraints
)
```

### **Verifier**

```python
from orchestrator.adapters.verifier import Verifier, VerificationConfig

# Configuration
verifier_config = VerificationConfig(
    timeout=20.0,
    max_retries=3,
    concurrent_verifications=5,
    tools=["static_analysis", "property_check", "test_execution"]
)

# Cr√©er le v√©rificateur
verifier = Verifier(verifier_config)

# Initialiser
await verifier.initialize(domain_spec)

# V√©rifier un candidat
result = await verifier.verify_candidate(
    candidate=candidate,
    specification=specification,
    constraints=constraints,
    context=context
)
```

### **AsyncScheduler**

```python
from orchestrator.scheduler.async_scheduler import AsyncScheduler, SchedulerConfig

# Configuration
scheduler_config = SchedulerConfig(
    max_concurrent_tasks=10,
    default_timeout=30.0,
    max_retries=3,
    enable_budget_management=True
)

# Cr√©er le planificateur
scheduler = AsyncScheduler(scheduler_config)

# D√©marrer
await scheduler.start()

# Ex√©cuter des t√¢ches concurrentes
results = await scheduler.execute_concurrent(
    tasks=[task1, task2, task3],
    timeouts=[10.0, 15.0, 20.0],
    task_names=["task1", "task2", "task3"]
)

# Arr√™ter
await scheduler.stop()
```

### **BudgetManager**

```python
from orchestrator.scheduler.budget_manager import BudgetManager, BudgetConfig

# Configuration
budget_config = BudgetConfig(
    default_timeout=30.0,
    warning_threshold=0.8,
    critical_threshold=0.95,
    overrun_threshold=1.0
)

# Cr√©er le gestionnaire de budget
budget_manager = BudgetManager(budget_config)

# D√©marrer
await budget_manager.start()

# D√©finir les budgets
await budget_manager.set_budget({
    "time": 180.0,
    "tokens": 50000,
    "api_calls": 100
})

# Consommer du budget
success = await budget_manager.consume_budget(
    budget_type=BudgetType.TIME,
    amount=10.0,
    operation="ae_step"
)

# V√©rifier le statut
status = await budget_manager.get_budget_status(BudgetType.TIME)
```

## üìà M√©triques et Monitoring

### **M√©triques d'Ex√©cution**

```python
# M√©triques de l'orchestrateur
state.metrics = {
    "duration": 120.5,
    "concepts_count": 15,
    "implications_count": 8,
    "candidates_count": 3,
    "verifications_count": 5,
    "incidents_count": 1,
    "pcaps_count": 4
}

# M√©triques du moteur AE
ae_stats = await ae_engine.get_synthesis_stats()
# {
#     "total_concepts": 15,
#     "total_implications": 8,
#     "execution_time": 45.2,
#     "concepts_per_second": 0.33,
#     "success_rate": 0.95
# }

# M√©triques du moteur CEGIS
cegis_stats = await cegis_engine.get_synthesis_stats()
# {
#     "total_candidates": 3,
#     "total_verifications": 5,
#     "success_rate": 0.6,
#     "convergence_rate": 0.8
# }
```

### **M√©triques des Adaptateurs**

```python
# M√©triques LLM
llm_stats = await llm_adapter.get_statistics()
# {
#     "total_requests": 25,
#     "successful_requests": 23,
#     "success_rate": 0.92,
#     "average_response_time": 2.5
# }

# M√©triques Verifier
verifier_stats = await verifier.get_statistics()
# {
#     "total_verifications": 15,
#     "successful_verifications": 12,
#     "success_rate": 0.8,
#     "average_verification_time": 1.2
# }
```

### **M√©triques du Planificateur**

```python
# Statut du planificateur
scheduler_status = await scheduler.get_status()
# {
#     "status": "running",
#     "active_tasks": 2,
#     "completed_tasks": 8,
#     "failed_tasks": 1,
#     "stats": {
#         "total_tasks": 11,
#         "completed_tasks": 8,
#         "failed_tasks": 1,
#         "cancelled_tasks": 0,
#         "timeout_tasks": 0,
#         "average_execution_time": 3.2
#     }
# }
```

## üö® Gestion des Incidents

### **Types d'Incidents**

```python
# Budget d√©pass√©
failreason = FailReasonFactory.create_time_budget_exceeded(
    component="orchestrator",
    operation="ae_phase",
    current_time=60.0,
    budget_limit=30.0
)

# Maximum d'it√©rations atteint
failreason = FailReasonFactory.create_max_iters_reached(
    component="cegis_engine",
    operation="refine",
    current_iters=10,
    max_iters=10
)

# Timeout
failreason = FailReasonFactory.create_timeout_exceeded(
    component="llm_adapter",
    operation="generate",
    timeout_duration=30.0
)

# V√©rification √©chou√©e
failreason = FailReasonFactory.create_verification_failed(
    component="verifier",
    operation="verify_candidate",
    failure_reason="Property violation",
    evidence=[{"type": "static_analysis", "result": "failed"}]
)
```

### **S√©v√©rit√© des Incidents**

```python
# Niveaux de s√©v√©rit√©
FailReasonSeverity.LOW      # Information
FailReasonSeverity.MEDIUM   # Avertissement
FailReasonSeverity.HIGH     # Erreur
FailReasonSeverity.CRITICAL # Critique
```

## üìÅ Structure des Fichiers

```
orchestrator/
‚îú‚îÄ‚îÄ orchestrator_v1.py           # Orchestrateur principal v1
‚îú‚îÄ‚îÄ engines/
‚îÇ   ‚îú‚îÄ‚îÄ real_ae_engine.py        # Moteur AE r√©el
‚îÇ   ‚îî‚îÄ‚îÄ real_cegis_engine.py    # Moteur CEGIS r√©el
‚îú‚îÄ‚îÄ adapters/
‚îÇ   ‚îú‚îÄ‚îÄ llm_adapter.py          # Adaptateur LLM
‚îÇ   ‚îú‚îÄ‚îÄ verifier.py             # V√©rificateur
‚îÇ   ‚îî‚îÄ‚îÄ oracle_adapter.py       # Adaptateur Oracle
‚îú‚îÄ‚îÄ scheduler/
‚îÇ   ‚îú‚îÄ‚îÄ async_scheduler.py      # Planificateur asynchrone
‚îÇ   ‚îú‚îÄ‚îÄ budget_manager.py       # Gestionnaire de budget
‚îÇ   ‚îî‚îÄ‚îÄ task_manager.py         # Gestionnaire de t√¢ches
‚îú‚îÄ‚îÄ incidents/
‚îÇ   ‚îú‚îÄ‚îÄ failreason.py           # Factory d'incidents
‚îÇ   ‚îî‚îÄ‚îÄ incident_manager.py     # Gestionnaire d'incidents
‚îî‚îÄ‚îÄ config.py                   # Configuration

tests/
‚îú‚îÄ‚îÄ test_orchestrator_v1.py     # Tests orchestrateur v1
‚îú‚îÄ‚îÄ test_real_ae_engine.py     # Tests moteur AE
‚îú‚îÄ‚îÄ test_real_cegis_engine.py  # Tests moteur CEGIS
‚îú‚îÄ‚îÄ test_llm_adapter.py        # Tests adaptateur LLM
‚îú‚îÄ‚îÄ test_verifier.py           # Tests v√©rificateur
‚îú‚îÄ‚îÄ test_async_scheduler.py    # Tests planificateur
‚îî‚îÄ‚îÄ test_budget_manager.py     # Tests gestionnaire budget

demo_orchestrator_v1.py         # D√©monstration compl√®te
Makefile.orchestrator_v1        # Makefile pour v1
README_ORCHESTRATOR_V1.md       # Documentation v1
```

## üéØ Crit√®res d'Acceptation

### **Fonctionnels**
- [x] Ex√©cution AE/CEGIS sans mocks c√¥t√© orchestrateur
- [x] Appels LLM/Verifier r√©ellement concurrents
- [x] Timeouts et retries observables dans les √©v√©nements
- [x] T√¢ches restantes cancell√©es proprement
- [x] Budget management avec backoff exponentiel
- [x] √âmission FailReason sur d√©passements

### **Techniques**
- [x] Moteurs r√©els injectables (DI)
- [x] Scheduler async avec asyncio.gather
- [x] Gestion des budgets avec seuils
- [x] Cancellation s√ªre des t√¢ches
- [x] √âmission d'incidents structur√©s
- [x] Tests complets sans mocks

### **Performance**
- [x] Ex√©cution concurrente LLM/Verifier
- [x] Timeouts par appel avec retry
- [x] Backoff exponentiel + jitter
- [x] Cancellation des t√¢ches restantes sur incident
- [x] Surveillance des budgets en temps r√©el

## üöÄ D√©monstration

### **Script de D√©monstration**

```bash
# D√©monstration compl√®te
python demo_orchestrator_v1.py

# Avec Makefile
make -f Makefile.orchestrator_v1 demo
```

### **R√©sultats Attendus**

```
üöÄ D√©marrage de la d√©monstration Orchestrateur v1
============================================================
üìÅ R√©pertoire d'audit temporaire: /tmp/orchestrator_v1_demo_xyz
‚úÖ Orchestrateur v1 initialis√©
üìã Domaine: RegTech Compliance Demo v1
üéØ Objets: 5
üîç Attributs: 5
üìù Contraintes: 3

üîÑ Ex√©cution de l'Orchestrateur v1...
üì° √âv√©nement: orchestrator.started
üì° √âv√©nement: ae.started
üì° √âv√©nement: cegis.started
üì° √âv√©nement: orchestrator.completed

‚úÖ Orchestrateur v1 termin√© en 45.2s
üìä Phase: completed
üÜî Run ID: 12345678-1234-1234-1234-123456789abc
üîó Trace ID: 87654321-4321-4321-4321-cba987654321

üìà R√©sultats AE:
  - Concepts: 3
    1. Concepts: 5, Implications: 2
    2. Concepts: 8, Implications: 3
    3. Concepts: 12, Implications: 5

üîß R√©sultats CEGIS:
  - Candidats: 2
    1. Candidat: candidate_1, V√©rifi√©: True
    2. Candidat: candidate_2, V√©rifi√©: True

‚ö†Ô∏è Incidents:
  - Total: 1
    - budget_warning: medium

üì¶ PCAPs:
  - Total: 4
    - ae_concept_generated: a1b2c3d4...
    - cegis_candidate_verified: e5f6g7h8...
    - cegis_candidate_refined: i9j0k1l2...
    - orchestrator_completed: m3n4o5p6...

üìä M√©triques:
  - duration: 45.2
  - concepts_count: 12
  - implications_count: 5
  - candidates_count: 2
  - verifications_count: 3
  - incidents_count: 1
  - pcaps_count: 4

üì° √âv√©nements:
  - Total: 25
    - orchestrator: 5
    - ae: 8
    - cegis: 10
    - budget: 2

üìÅ Audit Pack cr√©√©:
  - R√©pertoire: /tmp/orchestrator_v1_demo_xyz/packs/12345678-1234-1234-1234-123456789abc
    - manifest.json: 1024 bytes
    - pcaps.json: 2048 bytes
    - incidents.json: 512 bytes
    - journal.jsonl: 1536 bytes
    - metrics.json: 256 bytes

üîß Statistiques des composants:
  - LLM Adapter:
    - Requ√™tes: 15
    - Succ√®s: 14
    - Taux de succ√®s: 93.33%
  - Verifier:
    - V√©rifications: 8
    - Succ√®s: 6
    - Taux de succ√®s: 75.00%
  - Scheduler:
    - T√¢ches totales: 12
    - T√¢ches compl√©t√©es: 10
    - T√¢ches √©chou√©es: 1
  - Budget Manager:
    - time: 45.20/60.00 (75.3%)
    - tokens: 8500/10000 (85.0%)
    - api_calls: 15/50 (30.0%)

üéØ D√©monstration Orchestrateur v1 termin√©e avec succ√®s!
üìÅ Fichiers d'audit disponibles dans: /tmp/orchestrator_v1_demo_xyz
```

## üîó Liens

- **Documentation** : `README_ORCHESTRATOR_V1.md`
- **Tests** : `make -f Makefile.orchestrator_v1 test`
- **Demo** : `make -f Makefile.orchestrator_v1 demo`
- **Validation** : `make -f Makefile.orchestrator_v1 validate`

## üìù Notes

- **Version** : v1.0
- **D√©pendances** : Python 3.8+, asyncio, aiohttp, pytest
- **Licence** : MIT
- **Mainteneur** : Discovery Engine Team

---

**L'Orchestrator v1 est maintenant pr√™t pour la production avec des composants r√©els et une gestion industrielle des budgets, incidents et concurrence !** üöÄ
