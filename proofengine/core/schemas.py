"""Core data schemas used across the ProofEngine codebase."""

from __future__ import annotations

from datetime import datetime
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field, field_validator, model_validator


class VJustification(BaseModel):
    """Vector of costs/justifications attached to a PCAP entry or action."""

    time_ms: int = 0
    retries: int = 0
    backtracks: int = 0
    audit_cost: float = 0.0
    audit_cost_ms: int = 0
    risk: float = 0.0
    tech_debt: int = 0
    llm_time_ms: Optional[int] = None
    model: Optional[str] = None
    notes: Optional[str] = None

    @model_validator(mode="after")
    def _sync_audit_costs(self) -> "VJustification":
        """Keep the millisecond and float representations aligned."""

        if self.audit_cost and not self.audit_cost_ms:
            # By convention we map cost in ms when coming from float inputs.
            self.audit_cost_ms = int(self.audit_cost * 1000)
        elif self.audit_cost_ms and not self.audit_cost:
            self.audit_cost = self.audit_cost_ms / 1000.0
        # Ensure risk stays within bounds
        self.risk = max(0.0, min(1.0, self.risk))
        return self

    def to_dict(self) -> Dict[str, Any]:
        """Return a plain dict representation used by historical code."""

        return self.model_dump()


class Proof(BaseModel):
    """Structured proof artefact generated by verifiers/policies."""

    kind: str
    name: str
    passed: bool
    logs: str = ""
    artifacts: List[str] = Field(default_factory=list)
    metadata: Dict[str, Any] = Field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        return self.model_dump()


class ActionVariant(BaseModel):
    """Candidate action generated by the stochastic generator."""

    action_id: str
    description: str
    patch: str
    meta: Dict[str, Any] = Field(default_factory=dict)
    estimated_cost: VJustification = Field(default_factory=VJustification)
    confidence: float = 0.5

    @field_validator("confidence")
    @classmethod
    def _clamp_confidence(cls, value: float) -> float:
        return max(0.0, min(1.0, value))

    def to_dict(self) -> Dict[str, Any]:
        data = self.model_dump()
        data["estimated_cost"] = self.estimated_cost.to_dict()
        return data


class PlanProposal(BaseModel):
    """High level plan produced by the planner."""

    plan: List[str]
    est_success: float = Field(default=0.5, ge=0.0, le=1.0)
    est_cost: float = 0.0
    notes: str = ""
    llm_meta: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        return self.model_dump()


class PatchProposal(BaseModel):
    """Patch level proposal, typically produced by an LLM."""

    patch_unified: str
    rationale: str = ""
    predicted_obligations_satisfied: List[str] = Field(default_factory=list)
    risk_score: float = Field(default=0.5, ge=0.0, le=1.0)
    notes: str = ""
    llm_meta: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        return self.model_dump()


class PCAP(BaseModel):
    """Proof-Carrying Action log entry."""

    ts: Optional[str] = None
    operator: str
    case_id: Optional[str] = None
    action: Optional[str] = None
    pre: Dict[str, Any] = Field(default_factory=dict)
    post: Dict[str, Any] = Field(default_factory=dict)
    pre_hash: Optional[str] = None
    post_hash: Optional[str] = None
    obligations: List[str] = Field(default_factory=list)
    justification: VJustification = Field(default_factory=VJustification)
    proofs: List[Proof] = Field(default_factory=list)
    proof_state_hash: Optional[str] = None
    toolchain: Dict[str, Any] = Field(default_factory=dict)
    llm_meta: Optional[Dict[str, Any]] = None
    verdict: Optional[str] = None
    pcap_hash: Optional[str] = None

    @model_validator(mode="after")
    def _ensure_timestamp(self) -> "PCAP":
        if not self.ts:
            self.ts = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")
        return self

    def to_dict(self) -> Dict[str, Any]:
        data = self.model_dump()
        data["proofs"] = [proof.to_dict() for proof in self.proofs]
        return data

    def to_json(self) -> str:
        return self.model_dump_json(indent=2)


class _SetList(list):
    def add(self, value: Any) -> None:  # pragma: no cover - simple container helper
        if value not in self:
            self.append(value)


class XState(BaseModel):
    """Hybrid state Χ = {H, E, K, J, A, Σ}."""

    H: List[str] = Field(default_factory=list)
    E: List[str] = Field(default_factory=list)
    K: List[Any] = Field(default_factory=list)
    J: List[PCAP] = Field(default_factory=list)
    A: List[str] = Field(default_factory=list)
    Sigma: Dict[str, Any] = Field(default_factory=dict)
    state_hash: Optional[str] = None

    @model_validator(mode="after")
    def _wrap_collections(self) -> "XState":
        self.H = _SetList(self.H)
        self.E = _SetList(self.E)
        return self

    def to_dict(self) -> Dict[str, Any]:
        data = self.model_dump()
        data["H"] = list(self.H)
        data["E"] = list(self.E)
        data["J"] = [pcap.to_dict() for pcap in self.J]
        return data


class ObligationResults(BaseModel):
    """Result of running obligation checks on a workspace."""

    tests_ok: bool
    lint_ok: bool
    types_ok: bool
    security_ok: bool
    complexity_ok: bool
    docstring_ok: bool

    def violations_count(self) -> int:
        return sum(1 for value in self.model_dump().values() if not value)

    def all_passed(self) -> bool:
        return self.violations_count() == 0


class DeltaMetrics(BaseModel):
    """Detailed δ metrics supporting audit trails."""

    dH: float = Field(default=0.0, ge=0.0, le=1.0)
    dE: float = Field(default=0.0, ge=0.0, le=1.0)
    dK: float = Field(default=0.0, ge=0.0, le=1.0)
    dAST: float = Field(default=0.0, ge=0.0, le=1.0)
    violations_penalty: float = Field(default=0.0, ge=0.0, le=1.0)
    delta_total: float = Field(default=0.0, ge=0.0, le=1.0)

    def to_dict(self) -> Dict[str, Any]:
        return self.model_dump()


class Attestation(BaseModel):
    """Signed attestation over a PCAP directory."""

    ts: float
    pcap_count: int
    verdicts: List[Dict[str, Any]]
    digest: str
    signature: Optional[str] = None
